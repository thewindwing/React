<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:day3</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<h1 id="-app-3-">移动App第3天</h1>
<h2 id="reactjs-">ReactJS简介</h2>
<ul>
<li>React 起源于 Facebook 的内部项目，因为该公司对市场上所有 JavaScript MVC 框架，都不满意，就决定自己写一套，用来架设 Instagram 的网站。做出来以后，发现这套东西很好用，<strong>就在2013年5月开源了</strong>。</li>
<li>由于 React 的设计思想极其独特，属于革命性创新，性能出众，代码逻辑却非常简单。所以，越来越多的人开始关注和使用，认为它可能是将来 Web 开发的主流工具。</li>
<li>library</li>
<li>Framework</li>
</ul>
<h2 id="-">前端三大主流框架</h2>
<ul>
<li>Angular.js：出来最早的前端框架，学习曲线比较陡，NG1学起来比较麻烦，NG2开始，进行了一系列的改革，也开始启用组件化了；在NG中，也支持使用TS（TypeScript）进行编程；</li>
<li>Vue.js：最火的一门前端框架，它是中国人开发的，对我我们来说，文档要友好一些；</li>
<li>React.js：最流行的一门框架，因为它的设计很优秀；</li>
<li>windowsPhone 7    7.5   8   10</li>
</ul>
<h2 id="react-vue-js-">React与vue.js的对比</h2>
<h3 id="-">组件化方面</h3>
<ol>
<li>什么是模块化：从 <strong>代码</strong> 的角度，去分析问题，把我们编程时候的业务逻辑，分割到不同的模块中来进行开发，这样能够<strong>方便代码的重用</strong>；</li>
<li>什么是组件化：从 <strong>UI</strong> 的角度，去分析问题，把一个页面，拆分为一些互不相干的小组件，随着我们项目的开发，我们手里的组件会越来越多，最后，我们如果要实现一个页面，可能直接把现有的组件拿过来进行拼接，就能快速得到一个完整的页面， 这样方<strong>便了UI元素的重用</strong>；<strong>组件是元素的集合体</strong>；</li>
<li>组件化的好处：</li>
<li>Vue是如何实现组件化的：.vue 组件模板文件，浏览器不识别这样的.vue文件，所以，在运行前，会把 .vue 预先编译成真正的组件；<ul>
<li>template： UI结构</li>
<li>script： 业务逻辑和数据</li>
<li>style： UI的样式</li>
</ul>
</li>
<li>React如何实现组件化：在React中实现组件化的时候，根本没有 像 .vue 这样的模板文件，而是，直接使用JS代码的形式，去创建任何你想要的组件；<ul>
<li>React中的组件，都是直接在 js 文件中定义的；</li>
<li>React的组件，并没有把一个组件 拆分为 三部分（结构、样式、业务逻辑），而是全部使用JS来实现一个组件的；（也就是说：结构、样式、业务逻辑是混合在JS里面一起编写出来的）</li>
</ul>
</li>
</ol>
<h3 id="-">开发团队方面</h3>
<ul>
<li>React是由FaceBook前端官方团队进行维护和更新的；因此，React的维护开发团队，技术实力比较雄厚；</li>
<li>Vue：第一版，主要是有作者 尤雨溪 专门进行维护的，当 Vue更新到 2.x 版本后，也有了一个小团队进行相关的维护和开发；</li>
</ul>
<h3 id="-">社区方面</h3>
<ul>
<li>在社区方面，React由于诞生的较早，所以社区比较强大，一些常见的问题、坑、最优解决方案，文档、博客在社区中都是可以很方便就能找到的；</li>
<li>Vue是近两年才诞生开源出来的，所以，它的社区相对于React来说，要小巧一些，所以，可能有的一些坑，没人踩过；</li>
</ul>
<h3 id="-app-">移动APP开发体验方面</h3>
<ul>
<li>Vue，结合 Weex 这门技术，提供了 迁移到 移动端App开发的体验（Weex，目前只是一个 小的玩具， 并没有很成功的 大案例；）</li>
<li>React，结合 ReactNative，也提供了无缝迁移到 移动App的开发体验（RN用的最多，也是最火最流行的）；</li>
</ul>
<h2 id="-react">为什么要学习React</h2>
<ol>
<li>设计很优秀，是基于组件化的，方便我们UI代码的重用；</li>
<li>开发团队实力强悍，不必担心短更的情况；</li>
<li>社区强大，很多问题都能找到对应的解决方案；</li>
<li>提供了无缝转到 ReactNative 上的开发体验，让我们技术能力得到了拓展；增强了我们的核心竞争力</li>
</ol>
<h2 id="react-">React中几个核心的概念</h2>
<h3 id="-dom-virtual-document-object-model-">虚拟DOM（Virtual Document Object Model）</h3>
<ul>
<li>DOM的本质是什么：就是用JS表示的UI元素</li>
<li>DOM和虚拟DOM的区别：<ul>
<li>DOM是由浏览器中的JS提供功能，所以我们只能人为的使用 浏览器提供的固定的API来操作DOM对象；</li>
<li>虚拟DOM：并不是由浏览器提供的，而是我们程序员手动模拟实现的，类似于浏览器中的DOM，但是有着本质的区别；</li>
</ul>
</li>
<li>为什么要实现虚拟DOM：</li>
<li>什么是React中的虚拟DOM：</li>
<li>虚拟DOM的目的：
<img src="images/虚拟DOM引入图片.png" alt="虚拟DOM - 表格排序案例"></li>
</ul>
<h3 id="diff-">Diff算法</h3>
<ul>
<li>tree diff:新旧DOM树，逐层对比的方式，就叫做 tree diff,每当我们从前到后，把所有层的节点对比完后，必然能够找到那些 需要被更新的元素；</li>
<li>component diff：在对比每一层的时候，组件之间的对比，叫做 component diff;当对比组件的时候，如果两个组件的类型相同，则暂时认为这个组件不需要被更新，如果组件的类型不同，则立即将旧组件移除，新建一个组件，替换到被移除的位置；</li>
<li>element diff:在组件中，每个元素之间也要进行对比，那么，元素级别的对比，叫做 element diff；</li>
<li>key：key这个属性，可以把 页面上的 DOM节点 和 虚拟DOM中的对象，做一层关联关系；
<img src="images/Diff.png" alt="Diff算法图"></li>
</ul>
<h2 id="react-">React项目的创建</h2>
<ol>
<li>运行 <code>cnpm i react react-dom -S</code> 安装包</li>
<li>在项目中导入两个相关的包：<pre><code>// 1. 在 React 学习中，需要安装 两个包 react  react-dom
// 1.1 react 这个包，是专门用来创建React组件、组件生命周期等这些东西的；
// 1.2 react-dom 里面主要封装了和 DOM 操作相关的包，比如，要把 组件渲染到页面上
import React from &#39;react&#39;
import ReactDOM from &#39;react-dom&#39;
</code></pre></li>
<li><p>使用JS的创建虚拟DOM节点：</p>
<pre><code> // 2. 在 react 中，如要要创建 DOM 元素了，只能使用 React 提供的 JS API 来创建，不能【直接】像 Vue 中那样，手写 HTML 元素
 // React.createElement() 方法，用于创建 虚拟DOM 对象，它接收 3个及以上的参数
 // 参数1： 是个字符串类型的参数，表示要创建的元素类型
 // 参数2： 是一个属性对象，表示 创建的这个元素上，有哪些属性
 // 参数3： 从第三个参数的位置开始，后面可以放好多的虚拟DOM对象，这写参数，表示当前元素的子节点
 // &lt;div title=&quot;this is a div&quot; id=&quot;mydiv&quot;&gt;这是一个div&lt;/div&gt;

 var myH1 = React.createElement(&#39;h1&#39;, null, &#39;这是一个大大的H1&#39;)

 var myDiv = React.createElement(&#39;div&#39;, { title: &#39;this is a div&#39;, id: &#39;mydiv&#39; }, &#39;这是一个div&#39;, myH1)
</code></pre></li>
<li>使用 ReactDOM 把元素渲染到页面指定的容器中：<pre><code> // ReactDOM.render(&#39;要渲染的虚拟DOM元素&#39;, &#39;要渲染到页面上的哪个位置中&#39;)
 // 注意： ReactDOM.render() 方法的第二个参数，和vue不一样，不接受 &quot;#app&quot; 这样的字符串，而是需要传递一个 原生的 DOM 对象
 ReactDOM.render(myDiv, document.getElementById(&#39;app&#39;))
</code></pre></li>
</ol>
<h2 id="jsx-">JSX语法</h2>
<ol>
<li>如要要使用 JSX 语法，必须先运行 <code>cnpm i babel-preset-react -D</code>，然后再 <code>.babelrc</code> 中添加 语法配置；</li>
<li>JSX语法的本质：还是以 React.createElement 的形式来实现的，并没有直接把 用户写的 HTML代码，渲染到页面上；</li>
<li>如果要在 JSX 语法内部，书写 JS 代码了，那么，所有的JS代码，必须写到 {} 内部；</li>
<li>当 编译引擎，在编译JSX代码的时候，如果遇到了<code>&lt;</code>那么就把它当作 HTML代码去编译，如果遇到了 <code>{}</code> 就把 花括号内部的代码当作 普通JS代码去编译；</li>
<li>在{}内部，可以写任何符合JS规范的代码；</li>
<li>在JSX中，如果要为元素添加<code>class</code>属性了，那么，必须写成<code>className</code>，因为 <code>class</code>在ES6中是一个关键字；和<code>class</code>类似，label标签的 <code>for</code> 属性需要替换为 <code>htmlFor</code>.</li>
<li>在JSX创建DOM的时候，所有的节点，必须有唯一的根元素进行包裹；</li>
<li>如果要写注释了，注释必须放到 {} 内部</li>
</ol>
<h2 id="react-">React中：第一种创建组件的方式</h2>
<h2 id="-">第一种基本组件的创建方式</h2>
<h3 id="-">父组件向子组件传递数据</h3>
<h3 id="-">属性扩散</h3>
<h3 id="-">将组件封装到单独的文件中</h3>
<h2 id="react-">React中：第二种创建组件的方式</h2>
<h3 id="-es6-class-">了解ES6中class关键字的使用</h3>
<h3 id="-class-">基于class关键字创建组件</h3>
<ul>
<li>使用 class 关键字来创建组件<pre><code>class Person extends React.Component{
  // 通过报错提示得知：在class创建的组件中，必须定义一个render函数
  render(){
      // 在render函数中，必须返回一个null或者符合规范的虚拟DOM元素
      return &lt;div&gt;
          &lt;h1&gt;这是用 class 关键字创建的组件！&lt;/h1&gt;
      &lt;/div&gt;;
  }
}
</code></pre></li>
</ul>
<h2 id="-">两种创建组件方式的对比</h2>
<ol>
<li>用构造函数创建出来的组件：专业的名字叫做“无状态组件”</li>
<li>用class关键字创建出来的组件：专业的名字叫做“有状态组件”</li>
</ol>
<blockquote>
<p>用构造函数创建出来的组件，和用class创建出来的组件，这两种不同的组件之间的<strong>本质区别就是</strong>：有无state属性！！！
有状态组件和无状态组件之间的本质区别就是：有无state属性！</p>
</blockquote>
<h2 id="-">一个小案例，巩固有状态组件和无状态组件的使用</h2>
<h3 id="-for-">通过for循环生成多个组件</h3>
<ol>
<li>数据：<pre><code>CommentList = [
 { user: &#39;张三&#39;, content: &#39;哈哈，沙发&#39; },
 { user: &#39;张三2&#39;, content: &#39;哈哈，板凳&#39; },
 { user: &#39;张三3&#39;, content: &#39;哈哈，凉席&#39; },
 { user: &#39;张三4&#39;, content: &#39;哈哈，砖头&#39; },
 { user: &#39;张三5&#39;, content: &#39;哈哈，楼下山炮&#39; }
]
</code></pre></li>
</ol>
<h3 id="style-">style样式</h3>
<h2 id="-">总结</h2>
<p>理解React中虚拟DOM的概念
理解React中三种Diff算法的概念
使用JS中createElement的方式创建虚拟DOM
使用ReactDOM.render方法
使用JSX语法并理解其本质
掌握创建组件的两种方式
理解有状态组件和无状态组件的本质区别
理解props和state的区别</p>
<h2 id="-">相关文章</h2>
<ul>
<li><a href="http://www.cnblogs.com/tim100/p/6050514.html">React数据流和组件间的沟通总结</a></li>
<li><a href="https://segmentfault.com/q/1010000005876655/a-1020000005876751">单向数据流和双向绑定各有什么优缺点？</a></li>
<li><a href="https://www.zhihu.com/question/29504639?sort=created">怎么更好的理解虚拟DOM?</a></li>
<li><a href="http://www.css88.com/react/index.html">React中文文档 - 版本较低</a></li>
<li><a href="http://blog.csdn.net/yczz/article/details/49886061">React 源码剖析系列 － 不可思议的 react diff</a></li>
<li><a href="http://www.infoq.com/cn/articles/react-dom-diff?from=timeline&amp;isappinstalled=0">深入浅出React（四）：虚拟DOM Diff算法解析</a></li>
<li><a href="http://www.cocoachina.com/webapp/20150721/12692.html">一看就懂的ReactJs入门教程（精华版）</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/06/css_modules.html">CSS Modules 用法教程</a></li>
<li><a href="http://blog.csdn.net/itzhongzi/article/details/66045880">将MarkDown转换为HTML页面</a></li>
<li><a href="https://jingyan.baidu.com/article/0320e2c1c9cf0e1b87507b26.html">win7命令行 端口占用 查询进程号 杀进程</a></li>
</ul>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>